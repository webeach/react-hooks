# `useTimeout`

## Описание

Хук `useTimeout` запускает таймаут и возвращает состояние его завершения.

Поддерживает два варианта вызова:
- только длительность (в миллисекундах);
- колбэк и длительность.

Результат можно использовать как **кортеж** (`[isDone]`) или как **объект** (`{ isDone }`).

---

## Сигнатура

```ts
// Вариант 1: только длительность
function useTimeout(ms: number): UseTimeoutReturn;

// Вариант 2: колбэк + длительность
function useTimeout(callback: UseTimeoutCallback, ms: number): UseTimeoutReturn;
```

- **Параметры**
   - `ms` — длительность таймаута в миллисекундах.
   - `callback` *(опционально)* — функция, вызываемая после завершения таймаута. Получает фактическое время выполнения в миллисекундах.

- **Возвращает**
   - Объект‑структуру, доступную как:
      - Кортеж: `[isDone]`
      - Объект: `{ isDone }`

---

## Поведение

1. При первом вызове создаётся таймер с указанной длительностью.

2. После завершения таймера:
   - если значение `isDone` используется, оно переключается на `true`;
   - если был передан `callback`, он вызывается с фактическим временем выполнения.

3. Если компонент размонтируется до завершения таймера, таймаут очищается.

4. При изменении значения `ms` существующий таймер будет перезапущен с новой длительностью.

---

## Примеры

### 1) Только флаг завершения

```tsx
import { useTimeout } from '@webeach/react-hooks/useTimeout';

function Loader() {
  const { isDone } = useTimeout(2000);

  return isDone ? <span>Готово!</span> : <span>Загрузка...</span>;
}
```

### 2) С колбэком

```tsx
import { useTimeout } from '@webeach/react-hooks/useTimeout';

function Example() {
  useTimeout((elapsed) => {
    console.log(`Таймер завершился через ${elapsed} мс`);
  }, 1000);

  return <p>Ожидаем 1 секунду...</p>;
}
```

---

## Когда использовать

- Нужно показать индикатор загрузки на фиксированное время.
- Запуск действия через задержку.
- Получение фактического времени выполнения таймера (например, для логирования).

---

## Когда не использовать

- Если требуется **периодический** вызов — лучше использовать `useLoop`.
- Если важно обновлять состояние сразу после размонтирования или отмены — используйте контролируемые эффекты или `AbortController`.
- Если нужно управлять несколькими таймерами — предпочтительнее использовать кастомный менеджер таймеров.

---

## Частые ошибки

- Использование `isDone` без учёта ленивого обновления: значение обновится только если оно реально используется.
- Ожидание, что `callback` выполнится строго через `ms`. В реальности фактическое время зависит от загрузки потока и браузера.

---

## Типизация

**Экспортируемые типы**

- `UseTimeoutCallback`
   - Колбэк, вызываемый после завершения тайм-аута: `(actualTime: number) => void`.
      - `actualTime` — фактическое время (мс), прошедшее с момента запуска.

- `UseTimeoutReturn`
   - Гибрид: кортеж `[isDone]` **и** объект `{ isDone }`.

- `UseTimeoutReturnObject`
   - Объектная форма: `{ isDone: boolean }`.

- `UseTimeoutReturnTuple`
   - Кортежная форма: `[isDone: boolean]`.

---

## Смотрите также

- [useFrame](useFrame.md)
- [useFrameExtended](useFrameExtended.md)
- [useLoop](useLoop.md)
- [useTimeoutExtended](useTimeoutExtended.md)
