# `useSet`

## Описание

`useSet` — хук, создающий **реактивный** `Set`, который вызывает перерисовку компонента при мутациях (`add`, `delete`, `clear`, `replaceAll` и т.д.). Экземпляр множества **стабилен** между рендерами; начальные значения можно передать массивом или ленивой фабрикой.

---

## Сигнатура

```ts
function useSet<ValueType = any>(
  initialValues?: ReadonlyArray<ValueType> | (() => ReadonlyArray<ValueType>)
): ExtendedSet<ValueType>;
```

- **Параметры**
   - `initialValues?` — начальные значения. Поддерживается ленивый вариант: функция, возвращающая массив.

- **Возвращает**
   - Реактивную структуру, совместимую с `Set`, у которой мутации инициируют перерисовку.

---

## Примеры

### 1) Базовое использование: добавление/удаление с перерисовкой

```tsx
import { useSet } from '@webeach/react-hooks/useSet';

export function Tags() {
  const tags = useSet<string>(['react', 'hooks']);

  return (
    <div>
      <button onClick={() => tags.add('typescript')}>Add TS</button>
      <button onClick={() => tags.delete('react')}>Remove React</button>
      <div>Total: {tags.size}</div>
      <ul>
        {[...tags.values()].map((tag) => (
          <li key={tag}>{tag}</li>
        ))}
      </ul>
    </div>
  );
}
```

### 2) Полная замена содержимого (`replaceAll`)

```tsx
import { useEffect } from 'react';
import { useSet } from '@webeach/react-hooks/useSet';

type PermissionsProps = {
  fetchAll: () => Promise<string[]>;
}

export function Permissions(props: PermissionsProps) {
  const { fetchAll } = props;
  const permissions = useSet<string>();

  useEffect(() => {
    fetchAll().then((values) => {
      permissions.replaceAll(values);
    });
  }, [fetchAll]);

  return <div>Available: {permissions.size}</div>;
}
```

---

## Поведение

1. **Реактивность на мутациях**
  - Вызовы `add`, `delete`, `clear`, `replaceAll` инициируют перерисовку компонента.

2. **Стабильность экземпляра**
  - Возвращаемый объект сохраняет ссылочную идентичность на протяжении жизни компонента (подходит для пропов/зависимостей).

3. **Ленивая инициализация**
  - Если передать фабрику `() => values`, начальные данные будут вычислены один раз при первом рендере.

4. **Чтение без побочных эффектов**
  - Операции `has`, `values`, `entries` не вызывают перерисовку; ререндер происходит только после мутаций.

5. **Уникальность значений**
  - `Set` автоматически предотвращает дублирование элементов. Повторный вызов `add` с тем же значением не увеличит размер множества.

---

## Когда использовать

- Коллекции уникальных значений: наборы ID, список активных тегов, выбранные элементы.
- Когда нужен **стабильный Set-объект**, который компоненты могут напрямую мутировать.
- Для UI-сценариев, где удобно работать с множеством (уникальность, быстрая проверка через `.has`).

---

## Когда **не** использовать

- Если данные хранятся как пары ключ/значение (лучше использовать `useMap`).
- Когда нужен порядок вставки с дубликатами — используйте массивы.
- Если обновления редкие — можно обойтись простым `useState` с массивом.

---

## Частые ошибки

1. **Ожидание дубликатов**
   - `Set` хранит только уникальные значения. Повторное добавление того же значения не изменит размер множества, но всё равно вызовет перерисовку.

2. **Переинициализация множества**
   - Не создавайте новый экземпляр вручную внутри рендера. Используйте возвращаемый из `useSet` объект — он стабилен.

3. **Неправильные зависимости эффектов**
   - Ссылка на `Set` стабильна; добавление её в зависимости эффекта не приведёт к перезапуску при изменении содержимого. Для реакции на изменения используйте производные значения (`set.size`) или обрабатывайте обновления в логике компонента.

---

## Типизация

**Экспортируемые типы**

- `ExtendedSet<ValueType>`
   - Совместим с `Set`, но дополнительно предоставляет метод `replaceAll(values)` для атомарной пересборки содержимого.
   - Мутации (`add`/`delete`/`clear`/`replaceAll`) инициируют перерисовку компонента.

---

## Смотрите также

- [useCollection](useCollection.md)
- [useMap](useMap.md)
